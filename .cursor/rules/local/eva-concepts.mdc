---
description: Eva domain model — primitive types, connection semantics, execution model, and terminology. The vocabulary for all Eva design and implementation.
globs: []
---

# Eva Conceptual Model

Eva is a prompt programming IDE. Users compose **prompt programs** — visual
node graphs of connected primitives that define agent behaviors, knowledge,
constraints, integrations, and schedules. Programs serve as both development
tools (build a solution) and operational tools (run ongoing processes).

## Primitive Taxonomy — 8 Node Types

| Node | What it is | Key config |
|------|-----------|------------|
| **Agent** | LLM-backed reasoning node. Receives instructions + context, invokes tools, produces output. | Model, system prompt, response format, temperature, max tokens, max iterations, cost budget |
| **Knowledge** | First-class information source (static or dynamic). What an Agent "knows." | Content source (inline/file/URL/upstream), format (text/JSON/embedded), refresh policy (static/on-run/periodic) |
| **Connector** | Typed interface to an external system. Encapsulates credentials + available actions. | System type (Linear/GitHub/API/Codebase/etc.), credentials, endpoint/scope, action filter |
| **Action** | Deterministic operation — no LLM. Transforms data, calls APIs, formats output. Fast and cheap. | Operation type (template/code/API call/format), parameters, error handling mode |
| **Trigger** | Entry point that starts a Run. Cron, webhook, connector-event, or manual. | Trigger type, schedule expression or event filter, payload template |
| **Gate** | Evaluates a condition and routes to different output branches. | Condition expression, routing mode (binary/switch/filter), branch definitions |
| **Collector** | Waits for multiple inputs, combines into one output. | Strategy (wait-all/first-wins/accumulate), combination template, timeout |
| **Checkpoint** | Pauses Run for human review. Human approves, rejects, or modifies. | Reviewer instructions, notification channel, timeout policy, required reviewers |

### Naming Rationale

| Chosen | Rejected alternatives | Why |
|--------|----------------------|-----|
| Agent | Reasoner, Mind, LLM | Universal AI term; not too narrow, metaphorical, or implementation-specific |
| Knowledge | Context, Memory, Data, Facts | Implies structured understanding; avoids overloaded/generic/rigid terms |
| Connector | Integration, Service, Tool, Adapter | Evokes "plugging in"; avoids abstract/generic terms and LLM tool-use conflict |
| Action | Transform, Step, Task, Function, Command | Concrete and imperative; not too narrow, generic, or programming-specific |
| Trigger | Schedule, Event, Source, Initiator | Clear causation; not too narrow (schedule) or abstract (event) |
| Gate | Router, Switch, Branch, Conditional | Intuitive for non-programmers; avoids networking/programming/git connotations |
| Collector | Aggregator, Merge, Join, Combiner | Evokes gathering; avoids database/git/SQL connotations |
| Checkpoint | Approval, Review, Pause, Handoff | Familiar save-point metaphor; not too narrow, specific, mechanical, or final |

## Port System

Each node has typed input and output **ports**. Two port categories:

- **data** — runtime message flow (results, events, instructions)
- **resource** — static capability grants (knowledge access, tool access)

Edges connect output-to-input of the same category. Invalid connections prevented in editor.

### Ports by Node Type

| Node | Input ports | Output ports |
|------|------------|-------------|
| Agent | `instruction` (data), `context` (resource), `tools` (resource) | `output` (data) |
| Knowledge | `update` (data, optional) | `content` (resource) |
| Connector | — | `tools` (resource) |
| Action | `input` (data), `tools` (resource, optional) | `output` (data) |
| Trigger | — | `event` (data) |
| Gate | `input` (data) | named branches: `pass`/`fail` or `case_N`/`default` (data) |
| Collector | `input` (data, multi-connect) | `output` (data) |
| Checkpoint | `input` (data) | `approved` / `rejected` / `modified` (data) |

Every node also has an implicit `error` output port (data).

## Connection Semantics

**Message** — the data envelope flowing along data edges:
- `type`: string identifier (e.g., `"text"`, `"json"`, `"issue_list"`)
- `payload`: JSON-structured data
- `metadata`: trace ID, timestamp, source node ID, run ID

**Key rules:**
- Edges are directed (output → input) and unconditional
- Conditional routing lives in Gate nodes, not on edges
- Resource edges are static bindings (define access); data edges carry runtime payload
- Graph topology IS the permission model — Agents can only use wired Knowledge and Connectors

## Execution Model

### How a prompt program runs (push-based, event-driven)

1. **Trigger** fires → emits event Message → creates a **Run**
2. Messages propagate downstream through data edges
3. Node **activates** when all required data inputs have Messages
4. Agent nodes invoke LLM; Action nodes execute deterministically
5. Gate nodes evaluate and route; Collector nodes wait then combine
6. Checkpoint nodes pause Run until human acts
7. All terminal nodes complete → Run completes

Branches execute in parallel. Long-running ops (LLM calls, human review)
block their branch, not the Run.

### Program Lifecycle

| State | Meaning |
|-------|---------|
| **Draft** | Being authored. Can test subgraphs. Not deployed. |
| **Active** | Deployed. Triggers enabled. Runs created automatically or manually. |
| **Paused** | Triggers disabled. In-flight Runs continue to completion. |
| **Archived** | Read-only. Historical. No new Runs. |

Transitions: Draft → Active ↔ Paused → Archived. Draft → Archived.

### Run Lifecycle

| State | Meaning |
|-------|---------|
| pending | Created, not yet started |
| running | Nodes executing |
| waiting | Blocked at Checkpoint(s) |
| completed | All branches finished |
| failed | Unrecoverable error (retries exhausted, unwired error) |
| canceled | Manually stopped |

### Step (node execution within a Run)

| State | Meaning |
|-------|---------|
| pending | Not yet activated |
| running | Currently executing |
| completed | Finished successfully |
| failed | Errored after retries |
| skipped | Branch not taken (Gate routed elsewhere) |
| waiting | Paused at Checkpoint |

Steps are logged with inputs, outputs, duration, and status.

### Operational vs. One-shot

- **One-shot**: Manual Trigger only. User clicks Run, watches results.
- **Operational**: Automatic Triggers (cron/webhook/event). Runs accumulate. Primary activity is monitoring.
- Same program transitions between modes by adding/removing automatic Triggers.

### Error Handling

- Per-node retry policy (`RetryPolicy` on `AgentConfig`/`ActionConfig`):
  `agentRetryPolicy`/`actionRetryPolicy :: Maybe RetryPolicy`
  Fields: `retryMaxAttempts :: Int`, `retryBackoff :: BackoffStrategy`
  (BackoffFixed ms | BackoffExponential baseMs capMs), `retryTimeoutMs :: Maybe Int`
- Each retry attempt is logged to `log_entries`; `stepRetryCount` persisted
- Failed nodes emit on implicit `error` port (source port name `"error"`)
- Wired error ports → error `Message` propagated downstream; recovery logic
  (notification, fallback Agent, Checkpoint). Step state = `Failed`, Run continues.
- Unwired error → `skipDescendants` marks all reachable downstream nodes
  `StepSkipped`; `rcHasUnhandledError` flag set; other branches continue
- Run: `RunCompleted` if all branches succeed (or all errors handled);
  `RunFailed` if any unhandled (unwired) error occurred

## Design Decisions (from research)

| Decision | Inspired by | Rationale |
|----------|------------|-----------|
| Typed ports | ComfyUI | Prevent invalid connections; visual clarity |
| Message envelope | NiFi + Node-RED | Self-describing data; provenance tracking |
| Triggers as nodes | n8n | Activation is visible in the graph |
| Connectors as nodes | (Eva-specific) | Graph topology = permission model |
| Durable Runs | Temporal.io | Operational programs must survive restarts |
| data/resource port split | Unreal Blueprints (simplified) | Separate runtime flow from static capability grants |

## Terminology Glossary

| Term | Definition |
|------|-----------|
| **Eva** | The prompt programming IDE |
| **Prompt Program** | A named graph of nodes and edges defining an agent behavior or operational process |
| **Node** | A primitive in the graph (Agent, Knowledge, Connector, Action, Trigger, Gate, Collector, Checkpoint) |
| **Port** | Typed input/output connection point on a node. Category: `data` or `resource` |
| **Edge** | Directed connection from an output port to a compatible input port |
| **Message** | Typed data envelope (`type` + `payload` + `metadata`) flowing along data edges |
| **Run** | Single execution instance of a prompt program, created by a Trigger |
| **Step** | Execution of one node within a Run. Logged for debugging and audit |
| **Canvas** | Visual workspace for authoring prompt programs |
| **Draft / Active / Paused / Archived** | Program lifecycle states |
| **One-shot** | Program with manual Trigger only — run once, see results |
| **Operational** | Program with automatic Triggers — runs repeatedly, results accumulate |
